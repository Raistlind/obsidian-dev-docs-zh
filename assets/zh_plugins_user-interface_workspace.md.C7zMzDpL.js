import{_ as s,c as a,o as e,V as i}from"./chunks/framework.qP9-rlTe.js";const t="/obsidian-dev-docs-zh/assets/split和tabs.54LLdN6E.png",n="/obsidian-dev-docs-zh/assets/特殊split.QPP3psHp.png",r="/obsidian-dev-docs-zh/assets/root_split.Y54F8csC.png",p="/obsidian-dev-docs-zh/assets/left_right.342eqbSM.png",u=JSON.parse('{"title":"工作区","description":"","frontmatter":{},"headers":[],"relativePath":"zh/plugins/user-interface/workspace.md","filePath":"zh/plugins/user-interface/workspace.md","lastUpdated":1705556984000}'),l={name:"zh/plugins/user-interface/workspace.md"},h=i('<h1 id="工作区" tabindex="-1">工作区 <a class="header-anchor" href="#工作区" aria-label="Permalink to &quot;工作区&quot;">​</a></h1><hr><p>Obsidian 让你可以随时配置哪些内容对你可见。在不需要文件浏览器时将其隐藏，并排显示多个文档，或者在处理文档时显示文档大纲。应用程序窗口中可见内容的配置称为工作区。</p><p>工作区是以 <a href="https://en.wikipedia.org/wiki/Tree_(data_structure)" target="_blank" rel="noreferrer">树形数据结构</a> 的形式实现的，其上的每个节点都被称为 <a href="https://docs.obsidian.md/Reference/TypeScript+API/WorkspaceItem" target="_blank" rel="noreferrer">工作区项</a>。工作区项有两种类型： <a href="https://docs.obsidian.md/Reference/TypeScript+API/WorkspaceParent" target="_blank" rel="noreferrer">父节点</a> 和 <a href="https://docs.obsidian.md/Reference/TypeScript+API/WorkspaceLeaf" target="_blank" rel="noreferrer">叶子节点</a>。主要区别在于父节点可以包含子节点或其他父节点，而叶子节点则不能包含任何其它节点。</p><p>父节点分为两种类型，即 <a href="https://docs.obsidian.md/Reference/TypeScript+API/WorkspaceSplit" target="_blank" rel="noreferrer">splits</a> 和 <a href="https://docs.obsidian.md/Reference/TypeScript+API/WorkspaceTabs" target="_blank" rel="noreferrer">tabs</a>，它们决定了如何向用户展示子项： <img src="'+t+'" alt=""></p><ul><li>split会沿垂直或水平方向逐个排列其子项。</li><li>tabs每次只显示一个子项目，并隐藏其他项目。</li></ul><p>工作区下有三个特殊的split：left、right和root。下图是一个典型工作区的示例：</p><p><img src="'+n+'" alt=""></p><p>叶子是一个窗口，可以以不同方式显示内容。叶子的类型决定显示内容的方式，并与特定视图相对应。例如，类型为 <code>graph</code> 的叶子对应显示<a href="https://help.obsidian.md/Plugins/Graph+view" target="_blank" rel="noreferrer">graph view</a>。</p><h2 id="splits" tabindex="-1">Splits <a class="header-anchor" href="#splits" aria-label="Permalink to &quot;Splits&quot;">​</a></h2><p>默认情况下，root split 的排列方向为垂直方向。为其创建新叶子节点时，Obsidian 会在用户界面中创建一个新列。拆分叶子节点时，拆出的叶子节点会添加到新的split中。虽然根分隔项下可创建的层级数量没有明确限制，但实际上每多一个层级，其实用性就会减弱。 <img src="'+r+'" alt=""></p><p>left和right splits的工作方式略有不同。在侧边栏中拆分叶子时，Obsidian 会生成一个新的tabs，并将新叶子添加到它下面。实际上，这意味着它们在任何时候都只能有三层工作区项，而且直接子项必须是tabs。 <img src="'+p+`" alt=""></p><h2 id="检查工作区" tabindex="-1">检查工作区 <a class="header-anchor" href="#检查工作区" aria-label="Permalink to &quot;检查工作区&quot;">​</a></h2><p>您可以通过 <a href="https://docs.obsidian.md/Reference/TypeScript+API/App" target="_blank" rel="noreferrer">App</a> 对象访问工作区。下面的示例将打印工作区中每个叶的类型：</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Plugin } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;obsidian&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ExamplePlugin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Plugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  async</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> onload</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addRibbonIcon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dice&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Print leaf types&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.app.workspace.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">iterateAllLeaves</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">leaf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(leaf.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getViewState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().type);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="leaf-生命周期" tabindex="-1">Leaf 生命周期 <a class="header-anchor" href="#leaf-生命周期" aria-label="Permalink to &quot;Leaf 生命周期&quot;">​</a></h2><p>插件可以向工作区添加任何类型的叶子节点，也可以通过自定义<a href="./views.html">视图</a>定义新的叶子节点类型。以下是向工作区添加叶子节点的几种方法。有关更多方法，请参阅工作区。</p><ul><li>如果要在root split中添加新叶，请使用 <a href="https://docs.obsidian.md/Reference/TypeScript+API/Workspace/getLeaf" target="_blank" rel="noreferrer">getLeaf(true)</a>。</li><li>如果要在任何侧边栏中添加新的叶子节点，请使用 <a href="https://docs.obsidian.md/Reference/TypeScript+API/Workspace/getLeftLeaf" target="_blank" rel="noreferrer">getLeftLeaf()</a> 和 <a href="https://docs.obsidian.md/Reference/TypeScript+API/Workspace/getRightLeaf" target="_blank" rel="noreferrer">getRightLeaf()</a>。这两种方法都可以让你决定是否将叶子添加到新的split中。</li></ul><p>您也可以使用 <a href="https://docs.obsidian.md/Reference/TypeScript+API/Workspace/createLeafInParent" target="_blank" rel="noreferrer">createLeafInParent()</a> 将叶子明确添加到您选择的split中。</p><p>除非明确移除，否则插件添加到工作区的叶子节点即使在插件禁用后也会保留。插件有责任删除它们添加到工作区的叶子节点。</p><p>要从工作区移除叶子节点，请在要移除的叶子节点上调用 <a href="https://docs.obsidian.md/Reference/TypeScript+API/WorkspaceLeaf/detach" target="_blank" rel="noreferrer">detach()</a>。您也可以使用  <a href="https://docs.obsidian.md/Reference/TypeScript+API/Workspace/detachLeavesOfType" target="_blank" rel="noreferrer">detachLeavesOfType()</a> 移除某一类型的所有叶子节点。</p><h2 id="leaf-组" tabindex="-1">Leaf 组 <a class="header-anchor" href="#leaf-组" aria-label="Permalink to &quot;Leaf 组&quot;">​</a></h2><p>您可以使用 <a href="https://docs.obsidian.md/Reference/TypeScript+API/WorkspaceLeaf/setGroup" target="_blank" rel="noreferrer">setGroup()</a> 将多个叶子分配给同一个组，从而创建<a href="https://help.obsidian.md/User+interface/Workspace/Panes/Linked+pane" target="_blank" rel="noreferrer">linked panes</a> 。</p><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">leaves.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">leaf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> leaf.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setGroup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;group1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div>`,24),k=[h];function d(o,c,g,E,f,b){return e(),a("div",null,k)}const m=s(l,[["render",d]]);export{u as __pageData,m as default};
